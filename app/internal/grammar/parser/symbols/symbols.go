// Package symbols is generated by gogll. Do not edit.
package symbols

import (
	"bytes"
	"fmt"
)

type Symbol interface {
	isSymbol()
	IsNonTerminal() bool
	String() string
}

func (NT) isSymbol() {}
func (T) isSymbol()  {}

// NT is the type of non-terminals symbols
type NT int

const (
	NT_AddSub NT = iota
	NT_AddSubCont
	NT_MinMax
	NT_MinMaxCont
	NT_MulDiv
	NT_MulDivCont
	NT_Start
	NT_Unary
)

// T is the type of terminals symbols
type T int

const (
	T_0  T = iota // !
	T_1           // (
	T_2           // )
	T_3           // *
	T_4           // +
	T_5           // -
	T_6           // /
	T_7           // <
	T_8           // >
	T_9           // ?
	T_10          // [
	T_11          // ]
	T_12          // sym
	T_13          // {
	T_14          // }
)

type Symbols []Symbol

func (ss Symbols) Equal(ss1 Symbols) bool {
	if len(ss) != len(ss1) {
		return false
	}
	for i, s := range ss {
		if s.String() != ss1[i].String() {
			return false
		}
	}
	return true
}

func (ss Symbols) String() string {
	w := new(bytes.Buffer)
	for i, s := range ss {
		if i > 0 {
			fmt.Fprint(w, " ")
		}
		fmt.Fprintf(w, "%s", s)
	}
	return w.String()
}

func (ss Symbols) Strings() []string {
	strs := make([]string, len(ss))
	for i, s := range ss {
		strs[i] = s.String()
	}
	return strs
}

func (NT) IsNonTerminal() bool {
	return true
}

func (T) IsNonTerminal() bool {
	return false
}

func (nt NT) String() string {
	return ntToString[nt]
}

func (t T) String() string {
	return tToString[t]
}

// IsNT returns true iff sym is a non-terminal symbol of the grammar
func IsNT(sym string) bool {
	_, exist := stringNT[sym]
	return exist
}

// ToNT returns the NT value of sym or panics if sym is not a non-terminal of the grammar
func ToNT(sym string) NT {
	nt, exist := stringNT[sym]
	if !exist {
		panic(fmt.Sprintf("No NT: %s", sym))
	}
	return nt
}

var ntToString = []string{
	"AddSub",     /* NT_AddSub */
	"AddSubCont", /* NT_AddSubCont */
	"MinMax",     /* NT_MinMax */
	"MinMaxCont", /* NT_MinMaxCont */
	"MulDiv",     /* NT_MulDiv */
	"MulDivCont", /* NT_MulDivCont */
	"Start",      /* NT_Start */
	"Unary",      /* NT_Unary */
}

var tToString = []string{
	"!",   /* T_0 */
	"(",   /* T_1 */
	")",   /* T_2 */
	"*",   /* T_3 */
	"+",   /* T_4 */
	"-",   /* T_5 */
	"/",   /* T_6 */
	"<",   /* T_7 */
	">",   /* T_8 */
	"?",   /* T_9 */
	"[",   /* T_10 */
	"]",   /* T_11 */
	"sym", /* T_12 */
	"{",   /* T_13 */
	"}",   /* T_14 */
}

var stringNT = map[string]NT{
	"AddSub":     NT_AddSub,
	"AddSubCont": NT_AddSubCont,
	"MinMax":     NT_MinMax,
	"MinMaxCont": NT_MinMaxCont,
	"MulDiv":     NT_MulDiv,
	"MulDivCont": NT_MulDivCont,
	"Start":      NT_Start,
	"Unary":      NT_Unary,
}
